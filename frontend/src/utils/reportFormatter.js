/**
 * Utility functions for formatting analysis reports for AI tools
 */

/**
 * Formats analysis data into a well-structured text format suitable for AI tools
 * @param {Object} analysisData - The analysis data from the API
 * @returns {string} Formatted report text
 */
export const formatReportForAI = (analysisData) => {
  const { analysis_id, project_path, timestamp, summary, metrics, issues } = analysisData;
  
  let report = `# Code Quality Analysis Report\n\n`;
  
  // Header information
  report += `**Project:** ${project_path}\n`;
  report += `**Analysis ID:** ${analysis_id}\n`;
  report += `**Timestamp:** ${new Date(timestamp).toLocaleString()}\n\n`;
  
  // Summary section
  report += `## Summary\n\n`;
  report += `- **Quality Score:** ${summary.quality_score?.toFixed(2) || 0}/100\n`;
  report += `- **Total Issues:** ${issues.length}\n`;
  report += `- **Files Analyzed:** ${summary.files_analyzed || 0}\n`;
  
  if (summary.by_severity) {
    report += `- **Issues by Severity:**\n`;
    Object.entries(summary.by_severity).forEach(([severity, count]) => {
      report += `  - ${severity.charAt(0).toUpperCase() + severity.slice(1)}: ${count}\n`;
    });
  }
  
  if (summary.by_category) {
    report += `- **Issues by Category:**\n`;
    Object.entries(summary.by_category).forEach(([category, count]) => {
      report += `  - ${category.charAt(0).toUpperCase() + category.slice(1)}: ${count}\n`;
    });
  }
  
  if (summary.ai_issues_count) {
    report += `- **AI-Detected Issues:** ${summary.ai_issues_count}\n`;
  }
  
  report += `\n`;
  
  // Metrics section
  if (metrics && Object.keys(metrics).length > 0) {
    report += `## Code Metrics\n\n`;
    Object.entries(metrics).forEach(([metric, value]) => {
      report += `- **${metric}:** ${value}\n`;
    });
    report += `\n`;
  }
  
  // Issues section
  if (issues.length > 0) {
    report += `## Issues Found\n\n`;
    
    // Group issues by severity
    const issuesBySeverity = issues.reduce((acc, issue) => {
      if (!acc[issue.severity]) acc[issue.severity] = [];
      acc[issue.severity].push(issue);
      return acc;
    }, {});
    
    // Sort severities by priority
    const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
    
    severityOrder.forEach(severity => {
      if (issuesBySeverity[severity]) {
        report += `### ${severity.charAt(0).toUpperCase() + severity.slice(1)} Issues (${issuesBySeverity[severity].length})\n\n`;
        
        issuesBySeverity[severity].forEach((issue, index) => {
          report += `#### ${index + 1}. ${issue.title}\n\n`;
          report += `**Category:** ${issue.category}\n`;
          report += `**File:** \`${issue.file_path}\`${issue.line_number ? `:${issue.line_number}` : ''}\n`;
          report += `**Description:** ${issue.description}\n`;
          
          if (issue.suggestion) {
            report += `**Suggestion:** ${issue.suggestion}\n`;
          }
          
          // Add metadata if available
          if (issue.metadata) {
            if (issue.metadata.ai_detected) {
              report += `**Detection Method:** AI Analysis\n`;
            }
            if (issue.metadata.confidence) {
              report += `**Confidence:** ${(issue.metadata.confidence * 100).toFixed(1)}%\n`;
            }
          }
          
          report += `\n`;
        });
      }
    });
  } else {
    report += `## Issues Found\n\n`;
    report += `âœ… **No issues found!** Your code looks great.\n\n`;
  }
  
  // Footer
  report += `---\n`;
  report += `*This report was generated by Code Quality Intelligence Agent*\n`;
  report += `*Formatted for AI tools like Cursor, Claude, or ChatGPT*\n`;
  
  return report;
};

/**
 * Formats a single issue into a well-structured text format suitable for AI tools
 * @param {Object} issue - The issue data
 * @returns {string} Formatted issue text
 */
export const formatIssueForAI = (issue) => {
  let issueText = `# Code Quality Issue\n\n`;
  
  // Basic issue information
  issueText += `**Title:** ${issue.title}\n`;
  issueText += `**Severity:** ${issue.severity.toUpperCase()}\n`;
  issueText += `**Category:** ${issue.category}\n`;
  issueText += `**File:** \`${issue.file_path}\`${issue.line_number ? `:${issue.line_number}` : ''}\n\n`;
  
  // Description
  issueText += `## Description\n\n`;
  issueText += `${issue.description}\n\n`;
  
  // Suggestion if available
  if (issue.suggestion) {
    issueText += `## Suggestion\n\n`;
    issueText += `${issue.suggestion}\n\n`;
  }
  
  // Code snippet if available
  if (issue.code_snippet) {
    issueText += `## Code Snippet\n\n`;
    issueText += `\`\`\`${getFileLanguage(issue.file_path)}\n`;
    issueText += `${formatCodeSnippet(issue.code_snippet)}\n`;
    issueText += `\`\`\`\n\n`;
  }
  
  // Footer
  issueText += `---\n`;
  
  return issueText;
};

/**
 * Helper function to get file language from file path
 * @param {string} filePath - The file path
 * @returns {string} Language identifier
 */
const getFileLanguage = (filePath) => {
  const extension = filePath.split('.').pop()?.toLowerCase();
  const languageMap = {
    'py': 'python',
    'js': 'javascript',
    'jsx': 'javascript',
    'ts': 'typescript',
    'tsx': 'typescript',
    'java': 'java',
    'go': 'go',
    'rs': 'rust',
    'cpp': 'cpp',
    'c': 'c',
    'cs': 'csharp',
    'php': 'php',
    'rb': 'ruby',
    'swift': 'swift',
    'kt': 'kotlin',
    'scala': 'scala',
    'sh': 'bash',
    'bash': 'bash',
    'yaml': 'yaml',
    'yml': 'yaml',
    'json': 'json',
    'xml': 'xml',
    'html': 'html',
    'css': 'css',
    'scss': 'scss',
    'sass': 'sass',
    'less': 'less',
    'sql': 'sql',
    'md': 'markdown',
    'dockerfile': 'dockerfile'
  };
  return languageMap[extension] || 'text';
};

/**
 * Helper function to format code snippet for display
 * @param {string} snippet - The code snippet
 * @returns {string} Formatted code snippet
 */
const formatCodeSnippet = (snippet) => {
  if (!snippet) return '';
  
  // The snippet comes from backend with line numbers in format "1234|    code" or "1234|>>> code"
  // We'll preserve the line numbers and highlight the problematic line
  return snippet.split('\n').map(line => {
    // Match format: "1234|    code" or "1234|>>> code"
    const match = line.match(/^\s*(\d+)\|\s*(>>>\s*)?(.*)$/);
    if (match) {
      const [, lineNum, highlight, code] = match;
      if (highlight) {
        // This is the problematic line - we'll mark it for special styling
        return `>>> ${lineNum.padStart(4)} | ${code}`;
      } else {
        return `    ${lineNum.padStart(4)} | ${code}`;
      }
    }
    return line;
  }).join('\n');
};

/**
 * Copies text to clipboard with fallback for older browsers
 * @param {string} text - Text to copy
 * @returns {Promise<boolean>} Success status
 */
export const copyToClipboard = async (text) => {
  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.left = '-999999px';
      textArea.style.top = '-999999px';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      
      const success = document.execCommand('copy');
      document.body.removeChild(textArea);
      return success;
    }
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
};
